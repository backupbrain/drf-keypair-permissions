
# Crypto Keypair Authorization for Django Rest Framework

This Django module was created to give "Cavage" HTTP Signatures capabilities to the Django Rest Framework.

This enables HTTP authorization based on public key/private key encryption as an alternative to session cookies or API tokens.

In your Django code, it looks like this:
```python
from keypair_permissions.permissions import HasHttpCryptoAuthorization

class EchoServerApiView(GenericApiView):
    permission_classes = [HasHttpCryptoAuthorization]
    def get(self, request):
        return Response(request.body)

```

For more information see [Draft Cavage HTTP Signatures 12](https://tools.ietf.org/html/draft-cavage-http-signatures-12)

# Use

## Installing

Install using pip:
```
pip install drf-keypair-permissions
```

## Setup

To use with [Django Rest Framework](https://www.django-rest-framework.org/), you must
1. include `keypair_permissions` in your `INSTALLED_APPS` in your `settings.py`:

**settings.py**:
```python
INSTALLED_APPS = [
	...
	'keypair_permissions'
]
```

2. Migrate database

Run a database migration

```
$ ./manage.py makemigrations
$ ./manage.py migrate
```
3. Include `keypair_permissions.permissions.HasHttpCryptoAuthorization` in your `views.py`:

**views.py**:
```python
...
from keypair_permissions.permissions import HasHttpCryptoAuthorization
...
```
4. Set the `permission_classes` of API views to include `HasHttpCryptoAuthorization`:

**views.py**:
```python
class EchoServerApiView(GenericApiView):
    permission_classes = [HasHttpCryptoAuthorization]
    def get(self, request):
        return Response(request.body)
```

## Registering keys

Prior to using a public key to verify any signatures, you must register that public key with the server.

A `PublicKey` class is provided with the following fields:
| Field         | Required? | Type       | Description                                                        | Example                          |
|---------------|-----------|------------|--------------------------------------------------------------------|----------------------------------|
| user          | No        | ForeignKey | User who owns this key                                             |                                  |
| public_key_id | Yes       | String     | UUID Generated by the server, required by client for authorization | 6b7d3d9fbf4f4cdfbecb5d7903a7bdb5 |
| public_key    | Yes       | String     | compact-form text-encoded public key                               | MEYCIQ...jUyDrF                  |
| algorithm     | Yes       | String     | The signing and hashing algorithms to use with this public key     | (created) content-length         |
| created_at    | Yes       | DateTime   | Generated by Django                                                |                                  |
| is_active     | No        | Number     | Is the PublicKey active                                            | True                             |

### Deactivating keys
PublicKeys can be disabled by switching `is_active` to `False`. Doing so will prevent authorization from that key.

## Managing keys
You can manage keys in the Django admin:
`/admin/keypair_permissions/publickey/`

Here you will find a standard admin interface for adding, removing, and modifying PublicKeys.
## Algorithms
### Digest Algorithms

Digest algorithms are used to create a hash of the message body. The resulting hash is tagged with the hashing algorithm name and put in the `Digest` HTTP header.

The following algorithms are tested and working:
* SHA256
* SHA512

### Hash Algorithms
Hashing algorithms are used to hash a signing string used signature verification.

The hash algorithm must be stored as a part of the public key information prior to the public key's use as a verification tool.

The following hashing algorithms are tested and working:
* SHA256
* SHA512

### Signature Algorithms
Signature algorithms are used to verify a signed signing string that's generated by both the client and the server. 

The signature algorithm must be stored as part of the public key information prior to the public key's use as a verification tool

The following signature algorithms are tested and working:
* RSA
* Elliptic Curve P-256


# Authorization Requirements
* Signatures must be signed using private keys which have public keys counterparts registered on the server already.
* Client must maintain a copy of the server's public key id for any private key it uses to sign a signing string.
* Signatures, digests, and hash algorithms must be supported by the server

In order to use drf-keypair-permissions, you must provide some way for the user to register a public key and its sign and hash algorithms on the server. The server will provide a unique ID for each public key registered, which must be used to tell the server which key was used to sign each message.

The sign and hash algorithms are important for the server to verify signatures correlated with a public key.


# How Signatures are Constructed

- private key signs hash
- hash is created from headers + authorization parameters
- headers read
- parameters read
- generate signature

1. Create a digest hash of the message body (optional)

The request body can be signed with a digest, and that digest can be put into the `Digest` HTTP header, for example:

```
HTTP 1.1/POST /
Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
... (other HTTP headers)

{"hello":"world"}
```

This digest can be used both to verify that the message body is unaltered and to verify the signature.

The digest must include the hashing algorithm in the hash text in order to be verified, e.g. **SHA-256**=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE= or **MD5**=5d41402abc4b2a76b9719d911017c592

2. Add signature keys

The `Authorization` header must include certain keys, for example a `signature` and an `algorithm`. But it can also include optional fields such as the created timestamp, `created` or the expiration timestamp, `expires` or anything else you may want to include.

**Signature Keys**
| Field             | Required?                      | Type       | Description                                                        | Example                          |
|-------------------|--------------------------------|------------|--------------------------------------------------------------------|----------------------------------|
| user              | No                             | ForeignKey | User who owns this key                                             |                                  |
| public_key_id     | Yes                            | String     | UUID Generated by the server, required by client for authorization | 6b7d3d9fbf4f4cdfbecb5d7903a7bdb5 |
| public_key        | Yes                            | String     | compact-form text-encoded public key                               | MEYCIQ...jUyDrF                  |
| signing_algorithm | Yes                            | String     | The algorithm used to sign the hashed signing string               | (created) content-length         |
| hashing_algorithm | Yes if signing_algorithm='RSA' | String     | The algorithm used to hash the signing string                      |                                  |
| created_at        | Yes                            | Datetime   | Generated by Django                                                |                                  |
| is_active         | No                             | Number     | Is the PublicKey active                                            | True                             |

3. Build singing string

The signing string is constructed from one or more of the following HTTP headers and other parameters.

With the exception of `(request-target)`, parameters in parethesis (`()`) refer to keys in the Cavage signature

**Example Possible Signing Parameters**

| Parameter Name   | Example                                              |
|------------------|------------------------------------------------------|
| (request-target) | /foo?param=value&pet=dog                             |
| (created)        | 1402174295                                           |
| (expires)        | 1402170995                                           |
| Host             | example.com                                          |
| Date             | Sun, 05 Jan 2014 21:31:40 GMT                        |
| Content-Type     | application/json                                     |
| Digest           | SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE= |
| Content-Length   | 18                                                   |

These parameters are joined with newline (\n) characters to form the signing string. The HTTP headers and signature keys required to compose the signing string must be recorded in order in the `headers` signature key in order to verify the signature later.



A signing string with these parameters will be assembled into this string.
```
(request-target): /foo?param=value&pet=dog
(created): 1402174295
(expires): 1402170995
Host: example.com
Date: Sun, 05 Jan 2014 21:31:40 GMT
Content-Type: application/json
Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
Content-Length: 18
```
The `header` key for this signing string would be:

```
headers="(request-target) (created) (expires) host date, content-thank youpe digest content-length"
```

The signing string can be a single value, such as this, where only the `Digest` is used:

```
Digest: SHA-256=X48E9qOokqqrvdts8nOJRJN3OWDUoyWxBf7kbu9DBPE=
```

The `headers` key for this signing string would be:

```
headers="digest"
```

Or this, where only the `created` signature key is used:
```
(created): 1402174295
```

The `headers` key for this would be:
```
headers="(created)"
```

Or really any header or signature key.

**No headers key**
If no `headers` key is included in the signature, a `created` key must be included since the signature is verified against the `(created): <created_timestamp>` signing string when no `headers` key is supplied.

An empty `headers=""` is not allowed.

4. Sign signing string

The signing string must be:
a. hashed by a hashing algorithm compatible with one available on the server
b. signed by a signing algorithm compatible with one available on the server,
c. using a private key whose public key is already registered with the server.
d. must be Base64-encoded

This process will result in a Base64-encoded signature string such as:
`signature="MEYCIQD5dXAYp5Ih5wAhSapcJKnohaHgf5cid+yVouP1vaaI3wIhAK7jULnC/QBsd9ixeMOW7Vm41FpuzI31qIVChnjUyDrF"`

5. Record the algorithm

Currently the only algorithm set supported by drf-keypair-permissions is `hs2019`.

Therefore the header will include the line:

`algorithm="hs2019"`

6. Record the server's public key ID for the signing private key

The server must know which key was used. From this, it will  look up the hashing and signing algorithms used to sign the signing message and verify the signature.

`keyId="Test"`

6. Assemble the Authorization header

The authorization header will combine these signature keys as comma separated values to form a single `Authorization` HTTP header line.

For example, if the required headers were:
* `Content-Type`
* `Date`
* `(request-target)`

There is no `Digest` of the message body, the algorithm is `hs2019`, and the `keyId` is `Test`, then the resulting `Authorization` header may look like this:

```
Authorization: Signature keyId="Test",algorithm="hs2019",headers="content-type date (request-target)",signature="MEYCIQD5dXAYp5Ih5wAhSapcJKnohaHgf5cid+yVouP1vaaI3wIhAK7jULnC/QBsd9ixeMOW7Vm41FpuzI31qIVChnjUyDrF"
```

If, for example there were no required headers (defaulting to `(created)`), the `keyId` is `rsa-sha512-123`, and the algorithm is `hs2019`, then the resulting `Authorization` header may look like this:

```
Authorization: Signature keyId="rsa-sha512-123",algorithm="hs2019",signature="wAhSapcJKnohaHgf5cid+yVouP1vFpuzI31qIVChnjUyDrFaaI3wIhAK7jULnC/QBsd9ixeMEYCIQD5dXAYp5Ih5MOW7Vm41"
```

